\hypertarget{i2c_8c}{}\section{epcf\+\_\+project/epcf/peripheral/source/i2c/i2c.c File Reference}
\label{i2c_8c}\index{epcf\+\_\+project/epcf/peripheral/source/i2c/i2c.\+c@{epcf\+\_\+project/epcf/peripheral/source/i2c/i2c.\+c}}


This file is used to configure a I2C device.  


{\ttfamily \#include \char`\"{}pcf.\+h\char`\"{}}\newline
\subsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{i2c_8c_ada8f2ee61d9c3993af8d3d8ef6e48683}\label{i2c_8c_ada8f2ee61d9c3993af8d3d8ef6e48683}} 
\#define {\bfseries \+\_\+\+\_\+\+E\+P\+C\+F\+\_\+\+P\+R\+I\+V\+A\+T\+E\+\_\+\+I2\+C\+\_\+\+H\+\_\+\+I\+N\+C\+L\+U\+DE}~P\+C\+F\+\_\+\+C\+O\+N\+D\+I\+T\+I\+O\+N\+A\+L\+\_\+\+I\+N\+C\+L\+U\+D\+E\+\_\+\+F\+I\+LE(E\+P\+C\+F\+\_\+\+D\+I\+R\+\_\+\+P\+A\+TH/,peripheral/source/,i2c/,i2c\+\_\+hidden.\+h)
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$ \mbox{\hyperlink{i2c_8c_a3f687b5c66cbdbe03666613dcd9aef94}{epcf\+\_\+i2c\+\_\+\+Create\+Native}} (\mbox{\hyperlink{structEPCFI2cCfg__t}{E\+P\+C\+F\+I2c\+Cfg\+\_\+t}} $\ast$p\+I2c\+Config)
\begin{DoxyCompactList}\small\item\em This function is used to create a i2c device. Call this function in beginning to initialize the i2c device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling i2c functions. \end{DoxyCompactList}\item 
int32\+\_\+t \mbox{\hyperlink{i2c_8c_a24f35ecf200ff9e2dec3c2169f634b26}{epcf\+\_\+i2c\+\_\+write}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device, En\+E\+P\+C\+F\+Boolean\+\_\+t master\+Enable, uint8\+\_\+t slave\+Address, const uint8\+\_\+t $\ast$data, uint32\+\_\+t size, En\+E\+P\+C\+F\+Boolean\+\_\+t bus\+Release, E\+P\+C\+F\+Time\+\_\+t timeout)
\begin{DoxyCompactList}\small\item\em This function is used to send data on I2c bus. It can be used in both master and slave mode. In Interrupt mode, data transmission will be asynchronous and the data is transmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use E\+P\+C\+F\+\_\+\+I2c\+\_\+\+G\+E\+T\+\_\+\+T\+X\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT function to check the status of the transmit buffer. \end{DoxyCompactList}\item 
int32\+\_\+t \mbox{\hyperlink{i2c_8c_ad706f83fd8413715ac0bc5378b0015e5}{epcf\+\_\+i2c\+\_\+read}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device, En\+E\+P\+C\+F\+Boolean\+\_\+t master\+Enable, uint8\+\_\+t slave\+Address, uint8\+\_\+t $\ast$data, uint32\+\_\+t size, En\+E\+P\+C\+F\+Boolean\+\_\+t bus\+Release, E\+P\+C\+F\+Time\+\_\+t timeout)
\begin{DoxyCompactList}\small\item\em This function is used to read data on I2c bus. This function can be used in both master and slave mode. In Interrupt mode, data receiving is asynchronous and data is received in an internal software buffer. Use E\+P\+C\+F\+\_\+\+I2c\+\_\+\+G\+E\+T\+\_\+\+R\+X\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT function to get receive buffer count. When the count is equal to the required number of bytes to be read, call E\+P\+C\+F\+\_\+\+I2c\+\_\+\+R\+E\+AD function to read the buffer. \end{DoxyCompactList}\item 
int8\+\_\+t \mbox{\hyperlink{i2c_8c_acf0afd43ef7268ae9360c8ea70a54541}{epcf\+\_\+i2c\+\_\+int\+Enable}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device)
\begin{DoxyCompactList}\small\item\em This function is used to enable the I2c interrupt.\+It can be disabled by \mbox{\hyperlink{i2c_8h_a54aa1fdbfae89bd17958069e8d58e635}{epcf\+\_\+i2c\+\_\+int\+Disable()}} function. \end{DoxyCompactList}\item 
int8\+\_\+t \mbox{\hyperlink{i2c_8c_a54aa1fdbfae89bd17958069e8d58e635}{epcf\+\_\+i2c\+\_\+int\+Disable}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device)
\begin{DoxyCompactList}\small\item\em This function is used to disable the I2c interrupt. The device can be enabled again by \mbox{\hyperlink{i2c_8h_acf0afd43ef7268ae9360c8ea70a54541}{epcf\+\_\+i2c\+\_\+int\+Enable()}} function. \end{DoxyCompactList}\item 
int32\+\_\+t \mbox{\hyperlink{i2c_8c_acc241257a5efd5cd65f5da5ebeb59a65}{epcf\+\_\+i2c\+\_\+get\+Rx\+Buffer\+Count}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device)
\item 
int8\+\_\+t \mbox{\hyperlink{i2c_8c_a90d512b68b103443365474a689da05ee}{epcf\+\_\+i2c\+\_\+rx\+Buffer\+Flush}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device)
\item 
int32\+\_\+t \mbox{\hyperlink{i2c_8c_a53f89f9f23839f49a11c83ed229bb805}{epcf\+\_\+i2c\+\_\+get\+Tx\+Buffer\+Count}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device)
\item 
int8\+\_\+t \mbox{\hyperlink{i2c_8c_a7ede5bd8a347d4a1a9230bc2e796c6f7}{epcf\+\_\+i2c\+\_\+tx\+Buffer\+Flush}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device)
\item 
int8\+\_\+t \mbox{\hyperlink{i2c_8c_abad40cdebd822ac63221f357d5ef25fd}{epcf\+\_\+i2c\+\_\+close}} (\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$p\+I2c\+Device)
\begin{DoxyCompactList}\small\item\em This function is used to close the I2c device. It will free the memory allocated by the I2c device. \end{DoxyCompactList}\item 
uint8\+\_\+t \mbox{\hyperlink{i2c_8c_ab567c3d619e8d5576d316194be5fb803}{epcf\+\_\+i2c\+\_\+get\+Device\+Count}} ()
\begin{DoxyCompactList}\small\item\em This function is used to get the total number of available I2c devices. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{i2c_8c_ab53c4feb398f4a5db059f22e16477c96}\label{i2c_8c_ab53c4feb398f4a5db059f22e16477c96}} 
uint8\+\_\+t {\bfseries epcf\+\_\+i2c\+\_\+ext\+Get\+Device\+Count} (E\+P\+C\+F\+I2c\+Controller\+\_\+t $\ast$p\+I2c\+Controller)
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This file is used to configure a I2C device. 



\subsection{Function Documentation}
\mbox{\Hypertarget{i2c_8c_abad40cdebd822ac63221f357d5ef25fd}\label{i2c_8c_abad40cdebd822ac63221f357d5ef25fd}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+close@{epcf\+\_\+i2c\+\_\+close}}
\index{epcf\+\_\+i2c\+\_\+close@{epcf\+\_\+i2c\+\_\+close}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+close()}{epcf\_i2c\_close()}}
{\footnotesize\ttfamily int8\+\_\+t epcf\+\_\+i2c\+\_\+close (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device }\end{DoxyParamCaption})}



This function is used to close the I2c device. It will free the memory allocated by the I2c device. 


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return status. Refer to \char`\"{}../../common/status.\+h\char`\"{} header file for the appropriate status codes. 
\end{DoxyReturn}
\mbox{\Hypertarget{i2c_8c_a3f687b5c66cbdbe03666613dcd9aef94}\label{i2c_8c_a3f687b5c66cbdbe03666613dcd9aef94}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+\+Create\+Native@{epcf\+\_\+i2c\+\_\+\+Create\+Native}}
\index{epcf\+\_\+i2c\+\_\+\+Create\+Native@{epcf\+\_\+i2c\+\_\+\+Create\+Native}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+\+Create\+Native()}{epcf\_i2c\_CreateNative()}}
{\footnotesize\ttfamily \mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}}$\ast$ epcf\+\_\+i2c\+\_\+\+Create\+Native (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structEPCFI2cCfg__t}{E\+P\+C\+F\+I2c\+Cfg\+\_\+t}} $\ast$}]{p\+I2c\+Config }\end{DoxyParamCaption})}



This function is used to create a i2c device. Call this function in beginning to initialize the i2c device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling i2c functions. 


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Config} & Pointer to the i2c configuration structure.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
On success, it return the pointer to i2c device. On error, it returns N\+U\+LL. 
\end{DoxyReturn}
\mbox{\Hypertarget{i2c_8c_ab567c3d619e8d5576d316194be5fb803}\label{i2c_8c_ab567c3d619e8d5576d316194be5fb803}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+get\+Device\+Count@{epcf\+\_\+i2c\+\_\+get\+Device\+Count}}
\index{epcf\+\_\+i2c\+\_\+get\+Device\+Count@{epcf\+\_\+i2c\+\_\+get\+Device\+Count}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+get\+Device\+Count()}{epcf\_i2c\_getDeviceCount()}}
{\footnotesize\ttfamily uint8\+\_\+t epcf\+\_\+i2c\+\_\+get\+Device\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



This function is used to get the total number of available I2c devices. 

\begin{DoxyReturn}{Returns}
Returns the number of available I2c devices. 
\end{DoxyReturn}
\mbox{\Hypertarget{i2c_8c_acc241257a5efd5cd65f5da5ebeb59a65}\label{i2c_8c_acc241257a5efd5cd65f5da5ebeb59a65}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+get\+Rx\+Buffer\+Count@{epcf\+\_\+i2c\+\_\+get\+Rx\+Buffer\+Count}}
\index{epcf\+\_\+i2c\+\_\+get\+Rx\+Buffer\+Count@{epcf\+\_\+i2c\+\_\+get\+Rx\+Buffer\+Count}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+get\+Rx\+Buffer\+Count()}{epcf\_i2c\_getRxBufferCount()}}
{\footnotesize\ttfamily int32\+\_\+t epcf\+\_\+i2c\+\_\+get\+Rx\+Buffer\+Count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device }\end{DoxyParamCaption})}

This function is used to get number of bytes received in I2c receive buffer.


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return total number of received bytes
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Use this function only when I2c is configured in interrupt mode 
\end{DoxyNote}
\mbox{\Hypertarget{i2c_8c_a53f89f9f23839f49a11c83ed229bb805}\label{i2c_8c_a53f89f9f23839f49a11c83ed229bb805}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+get\+Tx\+Buffer\+Count@{epcf\+\_\+i2c\+\_\+get\+Tx\+Buffer\+Count}}
\index{epcf\+\_\+i2c\+\_\+get\+Tx\+Buffer\+Count@{epcf\+\_\+i2c\+\_\+get\+Tx\+Buffer\+Count}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+get\+Tx\+Buffer\+Count()}{epcf\_i2c\_getTxBufferCount()}}
{\footnotesize\ttfamily int32\+\_\+t epcf\+\_\+i2c\+\_\+get\+Tx\+Buffer\+Count (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device }\end{DoxyParamCaption})}

This function is used to get number of bytes pending in I2c transmit buffer.


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return total number of pending bytes
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Use this function only when I2c is configured in interrupt mode 
\end{DoxyNote}
\mbox{\Hypertarget{i2c_8c_a54aa1fdbfae89bd17958069e8d58e635}\label{i2c_8c_a54aa1fdbfae89bd17958069e8d58e635}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+int\+Disable@{epcf\+\_\+i2c\+\_\+int\+Disable}}
\index{epcf\+\_\+i2c\+\_\+int\+Disable@{epcf\+\_\+i2c\+\_\+int\+Disable}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+int\+Disable()}{epcf\_i2c\_intDisable()}}
{\footnotesize\ttfamily int8\+\_\+t epcf\+\_\+i2c\+\_\+int\+Disable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device }\end{DoxyParamCaption})}



This function is used to disable the I2c interrupt. The device can be enabled again by \mbox{\hyperlink{i2c_8h_acf0afd43ef7268ae9360c8ea70a54541}{epcf\+\_\+i2c\+\_\+int\+Enable()}} function. 


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device. \\
\hline
{\em int\+Type} & interrupt type to generate an interrupt.\+Refer Enum En\+E\+P\+C\+F\+Int\+Type\+\_\+t. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status. Refer to \char`\"{}../../common/status.\+h\char`\"{} header file for the appropriate status codes. 
\end{DoxyReturn}
\mbox{\Hypertarget{i2c_8c_acf0afd43ef7268ae9360c8ea70a54541}\label{i2c_8c_acf0afd43ef7268ae9360c8ea70a54541}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+int\+Enable@{epcf\+\_\+i2c\+\_\+int\+Enable}}
\index{epcf\+\_\+i2c\+\_\+int\+Enable@{epcf\+\_\+i2c\+\_\+int\+Enable}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+int\+Enable()}{epcf\_i2c\_intEnable()}}
{\footnotesize\ttfamily int8\+\_\+t epcf\+\_\+i2c\+\_\+int\+Enable (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device }\end{DoxyParamCaption})}



This function is used to enable the I2c interrupt.\+It can be disabled by \mbox{\hyperlink{i2c_8h_a54aa1fdbfae89bd17958069e8d58e635}{epcf\+\_\+i2c\+\_\+int\+Disable()}} function. 


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device. \\
\hline
{\em int\+Type} & interrupt type to generate an interrupt.\+Refer Enum En\+E\+P\+C\+F\+Int\+Type\+\_\+t.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
status. Refer to \char`\"{}../../common/status.\+h\char`\"{} header file for the appropriate status codes. 
\end{DoxyReturn}
\mbox{\Hypertarget{i2c_8c_ad706f83fd8413715ac0bc5378b0015e5}\label{i2c_8c_ad706f83fd8413715ac0bc5378b0015e5}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+read@{epcf\+\_\+i2c\+\_\+read}}
\index{epcf\+\_\+i2c\+\_\+read@{epcf\+\_\+i2c\+\_\+read}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+read()}{epcf\_i2c\_read()}}
{\footnotesize\ttfamily int32\+\_\+t epcf\+\_\+i2c\+\_\+read (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device,  }\item[{En\+E\+P\+C\+F\+Boolean\+\_\+t}]{master\+Enable,  }\item[{uint8\+\_\+t}]{slave\+Address,  }\item[{uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{size,  }\item[{En\+E\+P\+C\+F\+Boolean\+\_\+t}]{bus\+Release,  }\item[{E\+P\+C\+F\+Time\+\_\+t}]{timeout }\end{DoxyParamCaption})}



This function is used to read data on I2c bus. This function can be used in both master and slave mode. In Interrupt mode, data receiving is asynchronous and data is received in an internal software buffer. Use E\+P\+C\+F\+\_\+\+I2c\+\_\+\+G\+E\+T\+\_\+\+R\+X\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT function to get receive buffer count. When the count is equal to the required number of bytes to be read, call E\+P\+C\+F\+\_\+\+I2c\+\_\+\+R\+E\+AD function to read the buffer. 

In Polling mode, data receiving will be synchronous and calling function will be blocked until all the data is received or timeout has occurred.


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device \\
\hline
{\em master\+Enable} & Make it true if want to use this function in master mode. \\
\hline
{\em slave\+Address} & Address of the slave device \\
\hline
{\em data} & Pointer to buffer where data read is to be stored \\
\hline
{\em size} & Total number of bytes to be read \\
\hline
{\em bus\+Release} & Make it true if want to release the bus after receiving all data. \\
\hline
{\em timeout} & timeout value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return number of bytes read over I2c bus. Check status code if return value is less than 0. Refer to \char`\"{}../../common/status.\+h\char`\"{} header file for the appropriate status codes. 
\end{DoxyReturn}
\mbox{\Hypertarget{i2c_8c_a90d512b68b103443365474a689da05ee}\label{i2c_8c_a90d512b68b103443365474a689da05ee}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+rx\+Buffer\+Flush@{epcf\+\_\+i2c\+\_\+rx\+Buffer\+Flush}}
\index{epcf\+\_\+i2c\+\_\+rx\+Buffer\+Flush@{epcf\+\_\+i2c\+\_\+rx\+Buffer\+Flush}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+rx\+Buffer\+Flush()}{epcf\_i2c\_rxBufferFlush()}}
{\footnotesize\ttfamily int8\+\_\+t epcf\+\_\+i2c\+\_\+rx\+Buffer\+Flush (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device }\end{DoxyParamCaption})}

This function is used to flush I2c receive buffer.


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return status. Refer to \char`\"{}../../common/status.\+h\char`\"{} header file for the appropriate status codes.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Use this function only when I2c is configured in interrupt mode 
\end{DoxyNote}
\mbox{\Hypertarget{i2c_8c_a7ede5bd8a347d4a1a9230bc2e796c6f7}\label{i2c_8c_a7ede5bd8a347d4a1a9230bc2e796c6f7}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+tx\+Buffer\+Flush@{epcf\+\_\+i2c\+\_\+tx\+Buffer\+Flush}}
\index{epcf\+\_\+i2c\+\_\+tx\+Buffer\+Flush@{epcf\+\_\+i2c\+\_\+tx\+Buffer\+Flush}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+tx\+Buffer\+Flush()}{epcf\_i2c\_txBufferFlush()}}
{\footnotesize\ttfamily int8\+\_\+t epcf\+\_\+i2c\+\_\+tx\+Buffer\+Flush (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device }\end{DoxyParamCaption})}

This function is used to flush I2c transmit buffer.


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return status. Refer to \char`\"{}../../common/status.\+h\char`\"{} header file for the appropriate status codes.
\end{DoxyReturn}
\begin{DoxyNote}{Note}
Use this function only when I2c is configured in interrupt mode 
\end{DoxyNote}
\mbox{\Hypertarget{i2c_8c_a24f35ecf200ff9e2dec3c2169f634b26}\label{i2c_8c_a24f35ecf200ff9e2dec3c2169f634b26}} 
\index{i2c.\+c@{i2c.\+c}!epcf\+\_\+i2c\+\_\+write@{epcf\+\_\+i2c\+\_\+write}}
\index{epcf\+\_\+i2c\+\_\+write@{epcf\+\_\+i2c\+\_\+write}!i2c.\+c@{i2c.\+c}}
\subsubsection{\texorpdfstring{epcf\+\_\+i2c\+\_\+write()}{epcf\_i2c\_write()}}
{\footnotesize\ttfamily int32\+\_\+t epcf\+\_\+i2c\+\_\+write (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{i2c_8h_abad1f65160a59e1e3ceefa2645e755c6}{E\+P\+C\+F\+I2c\+Device\+\_\+t}} $\ast$}]{p\+I2c\+Device,  }\item[{En\+E\+P\+C\+F\+Boolean\+\_\+t}]{master\+Enable,  }\item[{uint8\+\_\+t}]{slave\+Address,  }\item[{const uint8\+\_\+t $\ast$}]{data,  }\item[{uint32\+\_\+t}]{size,  }\item[{En\+E\+P\+C\+F\+Boolean\+\_\+t}]{bus\+Release,  }\item[{E\+P\+C\+F\+Time\+\_\+t}]{timeout }\end{DoxyParamCaption})}



This function is used to send data on I2c bus. It can be used in both master and slave mode. In Interrupt mode, data transmission will be asynchronous and the data is transmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use E\+P\+C\+F\+\_\+\+I2c\+\_\+\+G\+E\+T\+\_\+\+T\+X\+\_\+\+B\+U\+F\+F\+E\+R\+\_\+\+C\+O\+U\+NT function to check the status of the transmit buffer. 

In Polling mode, data transmission will be synchronous and calling function will be blocked until all the data is transmitted or timeout has occurred.


\begin{DoxyParams}{Parameters}
{\em p\+I2c\+Device} & Pointer to the I2c device \\
\hline
{\em master\+Enable} & Make it true if want to use this function in master mode. \\
\hline
{\em slave\+Address} & Address of the slave device \\
\hline
{\em data} & Pointer to buffer where data to be write is stored \\
\hline
{\em size} & Total number of bytes to be read \\
\hline
{\em bus\+Release} & Make it true if want to release the bus after receiving all data. \\
\hline
{\em timeout} & timeout value.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
return total number of bytes send over I2c bus. Check status code if return value is less than 0. Refer to \char`\"{}../../common/status.\+h\char`\"{} header file for the appropriate status codes. 
\end{DoxyReturn}

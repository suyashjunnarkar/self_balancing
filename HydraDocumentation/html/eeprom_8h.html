<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: epcf_project/epcf/peripheral/include/eeprom/eeprom.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a3dd39be04874e8d0c4408dc2fbbe4d9.html">epcf_project</a></li><li class="navelem"><a class="el" href="dir_2f7e3134a884d190e855e94bbd69e569.html">epcf</a></li><li class="navelem"><a class="el" href="dir_2950bcd52e09015d6c88380a30574849.html">peripheral</a></li><li class="navelem"><a class="el" href="dir_a548efc7d0be6715eef5bc1ba3e353ae.html">include</a></li><li class="navelem"><a class="el" href="dir_a39407be6103d29accae8f8af82b1cc6.html">eeprom</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">eeprom.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file is used to configure a Eeprom device.  
<a href="#details">More...</a></p>

<p><a href="eeprom_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structEPCFEepromCfg__t.html">EPCFEepromCfg_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eeprom configuration structure.  <a href="structEPCFEepromCfg__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a74e33a7f4bc6f7ab1a817005d6ef6a6a"><td class="memItemLeft" align="right" valign="top"><a id="a74e33a7f4bc6f7ab1a817005d6ef6a6a"></a>
typedef struct EPCFEepromDevice&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a></td></tr>
<tr class="memdesc:a74e33a7f4bc6f7ab1a817005d6ef6a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Eeprom device. <br /></td></tr>
<tr class="separator:a74e33a7f4bc6f7ab1a817005d6ef6a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a26c17a51454c6b39295cc9af35b810cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a26c17a51454c6b39295cc9af35b810cf">EnEPCFEepromDataBits_t</a> { <a class="el" href="eeprom_8h.html#a26c17a51454c6b39295cc9af35b810cfad97689116aa14521f60ff6abead2769b">enEPCFEepromDataBits_8</a>, 
<a class="el" href="eeprom_8h.html#a26c17a51454c6b39295cc9af35b810cfa090c3b31c3b07a89b76e5abaa0e3c339">enEPCFEepromDataBits_16</a>, 
<a class="el" href="eeprom_8h.html#a26c17a51454c6b39295cc9af35b810cfae5319965c6e70ef742e5443d649a1d82">enEPCFEepromDataBits_32</a>, 
<a class="el" href="eeprom_8h.html#a26c17a51454c6b39295cc9af35b810cfab27752049d6f632719870ed3ae495e6b">enEPCFEepromDataBits_Max</a>
 }</td></tr>
<tr class="memdesc:a26c17a51454c6b39295cc9af35b810cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">8-bit read/write mode of eeprom  <a href="eeprom_8h.html#a26c17a51454c6b39295cc9af35b810cf">More...</a><br /></td></tr>
<tr class="separator:a26c17a51454c6b39295cc9af35b810cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7346cb343146562d19bb34fbdf09c2b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a7346cb343146562d19bb34fbdf09c2b8">epcf_eeprom_CreateNative</a> (<a class="el" href="structEPCFEepromCfg__t.html">EPCFEepromCfg_t</a> *pEepromConfig)</td></tr>
<tr class="memdesc:a7346cb343146562d19bb34fbdf09c2b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to create an eeprom device. Call this function in beginning to initialize the device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling eeprom functions.  <a href="#a7346cb343146562d19bb34fbdf09c2b8">More...</a><br /></td></tr>
<tr class="separator:a7346cb343146562d19bb34fbdf09c2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba6703616a21bad886a897552913e24"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a3ba6703616a21bad886a897552913e24">epcf_eeprom_write</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice, uint32_t offset, uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a3ba6703616a21bad886a897552913e24"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to write data in eeprom memory. In Interrupt mode, write operation will be asynchronous and the data is written using internal software buffer. The function will be non blocking and will return after initiating data write operation. Use epcf_eeprom_getTxBufferCount function to check the status of the write buffer.  <a href="#a3ba6703616a21bad886a897552913e24">More...</a><br /></td></tr>
<tr class="separator:a3ba6703616a21bad886a897552913e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe10f1df9367fe95f9de952acf7aa330"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#abe10f1df9367fe95f9de952acf7aa330">epcf_eeprom_read</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice, uint32_t offset, uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:abe10f1df9367fe95f9de952acf7aa330"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read data from eeprom memory. In Interrupt mode, data read is asyncronous and data is read in an internal software buffer. Use epcf_eeprom_getRxBufferCount function to get read buffer count. When the count is equal to the required number of bytes to be read, call epcf_eeprom_read function to read the buffer.  <a href="#abe10f1df9367fe95f9de952acf7aa330">More...</a><br /></td></tr>
<tr class="separator:abe10f1df9367fe95f9de952acf7aa330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace751110535e88e621b5ca6308244f47"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#ace751110535e88e621b5ca6308244f47">epcf_eeprom_erase</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice, uint32_t offset, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:ace751110535e88e621b5ca6308244f47"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to erase data from eeprom memory. Calling function will be blocked until all the data is erased or timeout has occurred. The function is a blocking call in both interrupt and polling mode.  <a href="#ace751110535e88e621b5ca6308244f47">More...</a><br /></td></tr>
<tr class="separator:ace751110535e88e621b5ca6308244f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e0f59140af60a63f21e91101affd3b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a37e0f59140af60a63f21e91101affd3b">epcf_eeprom_pageWrite</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice, uint32_t pageAddress, uint32_t offset, uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a37e0f59140af60a63f21e91101affd3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to write data in a page in eeprom memory. In Interrupt mode, write operation will be asynchronous and the data is written using internal software buffer. The function will be non blocking and will return after initiating data write operation. Use epcf_eeprom_getTxBufferCount function to check the status of the write buffer.  <a href="#a37e0f59140af60a63f21e91101affd3b">More...</a><br /></td></tr>
<tr class="separator:a37e0f59140af60a63f21e91101affd3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7863516e7e4705efe930c93249c0e926"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a7863516e7e4705efe930c93249c0e926">epcf_eeprom_pageRead</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice, uint32_t pageAddress, uint32_t offset, uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a7863516e7e4705efe930c93249c0e926"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read data from a page in eeprom memory. In Interrupt mode, data read is asyncronous and data is read in an internal software buffer. Use epcf_eeprom_getRxBufferCount function to get read buffer count. When the count is equal to the required number of bytes to be read, call epcf_eeprom_read function to read the buffer.  <a href="#a7863516e7e4705efe930c93249c0e926">More...</a><br /></td></tr>
<tr class="separator:a7863516e7e4705efe930c93249c0e926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e431e86b3ea6910c4ea6134a65f46cd"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a6e431e86b3ea6910c4ea6134a65f46cd">epcf_eeprom_pageErase</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice, uint32_t pageAddress, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a6e431e86b3ea6910c4ea6134a65f46cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to erase a page in eeprom memory. Calling function will be blocked until all the data is erased or timeout has occurred. The function is a blocking call in both interrupt and polling mode.  <a href="#a6e431e86b3ea6910c4ea6134a65f46cd">More...</a><br /></td></tr>
<tr class="separator:a6e431e86b3ea6910c4ea6134a65f46cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3523b7b6f3d7426c1d2a4cc397fc6b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a0c3523b7b6f3d7426c1d2a4cc397fc6b">epcf_eeprom_getRxBufferCount</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice)</td></tr>
<tr class="separator:a0c3523b7b6f3d7426c1d2a4cc397fc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacbd3645a9bcaef7d39ed32ee000cc2"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#afacbd3645a9bcaef7d39ed32ee000cc2">epcf_eeprom_rxBufferFlush</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice)</td></tr>
<tr class="separator:afacbd3645a9bcaef7d39ed32ee000cc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce4d13f7ee62c49d087b160440edac8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a3ce4d13f7ee62c49d087b160440edac8">epcf_eeprom_getTxBufferCount</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice)</td></tr>
<tr class="separator:a3ce4d13f7ee62c49d087b160440edac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3d81566bed2588cdf3622a14f64d1e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#a2f3d81566bed2588cdf3622a14f64d1e">epcf_eeprom_txBufferFlush</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice)</td></tr>
<tr class="separator:a2f3d81566bed2588cdf3622a14f64d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd656b9d34c5b7ab221748ace6bb762"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#adbd656b9d34c5b7ab221748ace6bb762">epcf_eeprom_close</a> (<a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *pEepromDevice)</td></tr>
<tr class="memdesc:adbd656b9d34c5b7ab221748ace6bb762"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to close the eeprom device. It will free the memory allocated by the eeprom device.  <a href="#adbd656b9d34c5b7ab221748ace6bb762">More...</a><br /></td></tr>
<tr class="separator:adbd656b9d34c5b7ab221748ace6bb762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2da8c10632374267cd0ec637806c55d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="eeprom_8h.html#af2da8c10632374267cd0ec637806c55d">epcf_eeprom_getDeviceCount</a> ()</td></tr>
<tr class="memdesc:af2da8c10632374267cd0ec637806c55d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the total number of available eeprom devices.  <a href="#af2da8c10632374267cd0ec637806c55d">More...</a><br /></td></tr>
<tr class="separator:af2da8c10632374267cd0ec637806c55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">This file is used to configure a Eeprom device. </p>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a26c17a51454c6b39295cc9af35b810cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c17a51454c6b39295cc9af35b810cf">&#9670;&nbsp;</a></span>EnEPCFEepromDataBits_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="eeprom_8h.html#a26c17a51454c6b39295cc9af35b810cf">EnEPCFEepromDataBits_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>8-bit read/write mode of eeprom </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a26c17a51454c6b39295cc9af35b810cfad97689116aa14521f60ff6abead2769b"></a>enEPCFEepromDataBits_8&#160;</td><td class="fielddoc"><p class="">8-bits eeprom read/write </p>
</td></tr>
<tr><td class="fieldname"><a id="a26c17a51454c6b39295cc9af35b810cfa090c3b31c3b07a89b76e5abaa0e3c339"></a>enEPCFEepromDataBits_16&#160;</td><td class="fielddoc"><p class="">16-bits eeprom read/write </p>
</td></tr>
<tr><td class="fieldname"><a id="a26c17a51454c6b39295cc9af35b810cfae5319965c6e70ef742e5443d649a1d82"></a>enEPCFEepromDataBits_32&#160;</td><td class="fielddoc"><p class="">32-bits eeprom read/write </p>
</td></tr>
<tr><td class="fieldname"><a id="a26c17a51454c6b39295cc9af35b810cfab27752049d6f632719870ed3ae495e6b"></a>enEPCFEepromDataBits_Max&#160;</td><td class="fielddoc"><p class="">Special value for boundary checking </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="adbd656b9d34c5b7ab221748ace6bb762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd656b9d34c5b7ab221748ace6bb762">&#9670;&nbsp;</a></span>epcf_eeprom_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_eeprom_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to close the eeprom device. It will free the memory allocated by the eeprom device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="a7346cb343146562d19bb34fbdf09c2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7346cb343146562d19bb34fbdf09c2b8">&#9670;&nbsp;</a></span>epcf_eeprom_CreateNative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a>* epcf_eeprom_CreateNative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEPCFEepromCfg__t.html">EPCFEepromCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to create an eeprom device. Call this function in beginning to initialize the device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling eeprom functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromConfig</td><td>Pointer to the eeprom configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, it return the pointer to eeprom device. On error, it returns NULL. </dd></dl>

</div>
</div>
<a id="ace751110535e88e621b5ca6308244f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace751110535e88e621b5ca6308244f47">&#9670;&nbsp;</a></span>epcf_eeprom_erase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_eeprom_erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to erase data from eeprom memory. Calling function will be blocked until all the data is erased or timeout has occurred. The function is a blocking call in both interrupt and polling mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device </td></tr>
    <tr><td class="paramname">offset</td><td>Address offset.Refer to platform specific header file for appropriate address range Erase operations to a misaligned address will result in an error response. For example: a 32-bit(dataBits = enEPCFEepromDataBits_32) erase operation to an address offset other than a multiple of 0x4 will result into error. </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to erase </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes erased from eeprom memory. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="af2da8c10632374267cd0ec637806c55d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2da8c10632374267cd0ec637806c55d">&#9670;&nbsp;</a></span>epcf_eeprom_getDeviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_eeprom_getDeviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the total number of available eeprom devices. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of available eeprom devices. </dd></dl>

</div>
</div>
<a id="a0c3523b7b6f3d7426c1d2a4cc397fc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3523b7b6f3d7426c1d2a4cc397fc6b">&#9670;&nbsp;</a></span>epcf_eeprom_getRxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_eeprom_getRxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to get number of bytes read in eeprom read buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of read bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when eeprom is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a3ce4d13f7ee62c49d087b160440edac8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce4d13f7ee62c49d087b160440edac8">&#9670;&nbsp;</a></span>epcf_eeprom_getTxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_eeprom_getTxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to get number of bytes pending in eeprom write buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of pending bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when eeprom is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a6e431e86b3ea6910c4ea6134a65f46cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e431e86b3ea6910c4ea6134a65f46cd">&#9670;&nbsp;</a></span>epcf_eeprom_pageErase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_eeprom_pageErase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to erase a page in eeprom memory. Calling function will be blocked until all the data is erased or timeout has occurred. The function is a blocking call in both interrupt and polling mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device </td></tr>
    <tr><td class="paramname">pageAddress</td><td>Address of the specific page of eeprom </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If page management is not supported in the eeprom this function will return an appropriate error response. </dd></dl>

</div>
</div>
<a id="a7863516e7e4705efe930c93249c0e926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7863516e7e4705efe930c93249c0e926">&#9670;&nbsp;</a></span>epcf_eeprom_pageRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_eeprom_pageRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read data from a page in eeprom memory. In Interrupt mode, data read is asyncronous and data is read in an internal software buffer. Use epcf_eeprom_getRxBufferCount function to get read buffer count. When the count is equal to the required number of bytes to be read, call epcf_eeprom_read function to read the buffer. </p>
<p class="">In Polling mode, data read will be synchronous and calling function will be blocked until all the data is received or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device </td></tr>
    <tr><td class="paramname">pageAddress</td><td>Address of the specific page of eeprom </td></tr>
    <tr><td class="paramname">offset</td><td>Address offset. Refer to platform specific header file for appropriate address range Read operations to a misaligned address will result in an error response. For example: a 32-bit(dataBits = enEPCFEepromDataBits_32) read operation to an address offset other than a multiple of 0x4 will result into error. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be read is stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to be read </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return number of bytes read from eeprom memory. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If page management is not supported in the eeprom this function will return an appropriate error response. <pre class="fragment">     If value of dataBits is set to greater than 8 bits. Then, 2 consecutive bytes will represent
     1 single data word. In this case value of size should be in a multiple of 2. If the value of size
     is an odd value, then a 0 is padded as the last byte of the data.</pre> </dd></dl>

</div>
</div>
<a id="a37e0f59140af60a63f21e91101affd3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e0f59140af60a63f21e91101affd3b">&#9670;&nbsp;</a></span>epcf_eeprom_pageWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_eeprom_pageWrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>pageAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to write data in a page in eeprom memory. In Interrupt mode, write operation will be asynchronous and the data is written using internal software buffer. The function will be non blocking and will return after initiating data write operation. Use epcf_eeprom_getTxBufferCount function to check the status of the write buffer. </p>
<p class="">In Polling mode, data write operation will be synchronous and calling function will be blocked until all the data is written or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device </td></tr>
    <tr><td class="paramname">pageAddress</td><td>Address of the specific page of eeprom </td></tr>
    <tr><td class="paramname">offset</td><td>Address offset.Refer to platform specific header file for appropriate address range Write operations to a misaligned address will result in an error response. For example: a 32-bit(dataBits = enEPCFEepromDataBits_32) write operation to an address offset other than a multiple of 0x4 will result into error. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be written is stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to write. </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes written in eeprom memory. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If page management is not supported in the eeprom this function will return an appropriate error response. <pre class="fragment">     If value of dataBits is set to greater than 8 bits. Then, 2 consecutive bytes will represent
     1 single data word. In this case value of size should be in a multiple of 2. If the value of size
     is an odd value, then a 0 is padded as the last byte of the data.</pre> </dd></dl>

</div>
</div>
<a id="abe10f1df9367fe95f9de952acf7aa330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe10f1df9367fe95f9de952acf7aa330">&#9670;&nbsp;</a></span>epcf_eeprom_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_eeprom_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read data from eeprom memory. In Interrupt mode, data read is asyncronous and data is read in an internal software buffer. Use epcf_eeprom_getRxBufferCount function to get read buffer count. When the count is equal to the required number of bytes to be read, call epcf_eeprom_read function to read the buffer. </p>
<p class="">In Polling mode, data read will be synchronous and calling function will be blocked until all the data is received or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device </td></tr>
    <tr><td class="paramname">offset</td><td>Address offset. Refer to platform specific header file for appropriate address range Read operations to a misaligned address will result in an error response. For example: a 32-bit(dataBits = enEPCFEepromDataBits_32) read operation to an address offset other than a multiple of 0x4 will result into error. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be read is stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to be read </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return number of bytes read from eeprom memory. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If value of dataBits is set to greater than 8 bits. Then, 2 consecutive bytes will represent 1 single data word. In this case value of size should be in a multiple of 2. If the value of size is an odd value, then a 0 is padded as the last byte of the data. </dd></dl>

</div>
</div>
<a id="afacbd3645a9bcaef7d39ed32ee000cc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacbd3645a9bcaef7d39ed32ee000cc2">&#9670;&nbsp;</a></span>epcf_eeprom_rxBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_eeprom_rxBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to flush eeprom read buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when Eeprom is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a2f3d81566bed2588cdf3622a14f64d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3d81566bed2588cdf3622a14f64d1e">&#9670;&nbsp;</a></span>epcf_eeprom_txBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_eeprom_txBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to flush eeprom write buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when eeprom is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a3ba6703616a21bad886a897552913e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba6703616a21bad886a897552913e24">&#9670;&nbsp;</a></span>epcf_eeprom_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_eeprom_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="eeprom_8h.html#a74e33a7f4bc6f7ab1a817005d6ef6a6a">EPCFEepromDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pEepromDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to write data in eeprom memory. In Interrupt mode, write operation will be asynchronous and the data is written using internal software buffer. The function will be non blocking and will return after initiating data write operation. Use epcf_eeprom_getTxBufferCount function to check the status of the write buffer. </p>
<p class="">In Polling mode, data write operation will be synchronous and calling function will be blocked until all the data is written or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEepromDevice</td><td>Pointer to the eeprom device </td></tr>
    <tr><td class="paramname">offset</td><td>Address offset.Refer to platform specific header file for appropriate address range Write operations to a misaligned address will result in an error response. For example: a 32-bit(dataBits = enEPCFEepromDataBits_32) write operation to an address offset other than a multiple of 0x4 will result into error. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be written is stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to write </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes written in eeprom memory. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If value of dataBits is set to greater than 8 bits. Then, 2 consecutive bytes will represent 1 single data word. In this case value of size should be in a multiple of 2. If the value of size is an odd value, then a 0 is padded as the last byte of the data. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: epcf_project/epcf/peripheral/source/uart/uart.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a3dd39be04874e8d0c4408dc2fbbe4d9.html">epcf_project</a></li><li class="navelem"><a class="el" href="dir_2f7e3134a884d190e855e94bbd69e569.html">epcf</a></li><li class="navelem"><a class="el" href="dir_2950bcd52e09015d6c88380a30574849.html">peripheral</a></li><li class="navelem"><a class="el" href="dir_a432507043b74a36ac7bfda595ba2ea5.html">source</a></li><li class="navelem"><a class="el" href="dir_7c39fc52b59ede5ead190cdae74d3889.html">uart</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">uart.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file is used to configure a UART device.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;pcf.h&quot;</code><br />
<code>#include &quot;<a class="el" href="uart__hidden_8h_source.html">./uart_hidden.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a83fec052dfd6ab2d064f81eeb7f2db69"><td class="memItemLeft" align="right" valign="top"><a id="a83fec052dfd6ab2d064f81eeb7f2db69"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__EPCF_UTIL_FIFO_INCLUDE</b>&#160;&#160;&#160;PCF_CONDITIONAL_INCLUDE_FILE(EPCF_DIR_PATH/,utils/,include/,epcf_fifo.h)</td></tr>
<tr class="separator:a83fec052dfd6ab2d064f81eeb7f2db69"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaacfd07a33e8060b8acf2a8a4e17924d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#aaacfd07a33e8060b8acf2a8a4e17924d">epcf_uart_createNative</a> (<a class="el" href="structEPCFUartCfg.html">EPCFUartCfg_t</a> *pUartConfig)</td></tr>
<tr class="memdesc:aaacfd07a33e8060b8acf2a8a4e17924d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to create an uart device. Call this function in beginning to initialize the device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling uart functions.  <a href="#aaacfd07a33e8060b8acf2a8a4e17924d">More...</a><br /></td></tr>
<tr class="separator:aaacfd07a33e8060b8acf2a8a4e17924d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f5e90dda2ee0090d3f4556ee78f739"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#a43f5e90dda2ee0090d3f4556ee78f739">epcf_uart_close</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice)</td></tr>
<tr class="memdesc:a43f5e90dda2ee0090d3f4556ee78f739"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to close the uart device. It will free the memory allocated by the uart device.  <a href="#a43f5e90dda2ee0090d3f4556ee78f739">More...</a><br /></td></tr>
<tr class="separator:a43f5e90dda2ee0090d3f4556ee78f739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995f3c9ed32f18ef7aa69b8966983116"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#a995f3c9ed32f18ef7aa69b8966983116">epcf_uart_write</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice, const uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a995f3c9ed32f18ef7aa69b8966983116"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send data over uart channel. Use this function in interrupt mode. Data transmission will be asynchronous and the data is transmmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use epcf_uart_getTxBufferCount function to check the status of the transmit buffer.  <a href="#a995f3c9ed32f18ef7aa69b8966983116">More...</a><br /></td></tr>
<tr class="separator:a995f3c9ed32f18ef7aa69b8966983116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab122d792b78dbf161bb312b572376a62"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#ab122d792b78dbf161bb312b572376a62">epcf_uart_writeString</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice, const uint8_t *data, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:ab122d792b78dbf161bb312b572376a62"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to write string data on uart channel. In Interrupt mode, data transmission will be asynchronous and the data is transmmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use epcf_uart_getTxBufferCount function to check the status of the transmit buffer.  <a href="#ab122d792b78dbf161bb312b572376a62">More...</a><br /></td></tr>
<tr class="separator:ab122d792b78dbf161bb312b572376a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4b4fe3d04fe4bdfbfa0cfd48f36cdb0"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#aa4b4fe3d04fe4bdfbfa0cfd48f36cdb0">epcf_uart_read</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice, uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:aa4b4fe3d04fe4bdfbfa0cfd48f36cdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read data on uart channel. In Interrupt mode, data receiving is asyncronous and data is received in an internal software buffer. Use epcf_uart_getRxBufferCount function to get receive buffer count. When the count is equal to the required number of bytes to be read, call EPCF_UART_READ function to read the buffer.  <a href="#aa4b4fe3d04fe4bdfbfa0cfd48f36cdb0">More...</a><br /></td></tr>
<tr class="separator:aa4b4fe3d04fe4bdfbfa0cfd48f36cdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c361423caa8763f433cd901c849b5a1"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#a0c361423caa8763f433cd901c849b5a1">epcf_uart_getDeviceCount</a> ()</td></tr>
<tr class="memdesc:a0c361423caa8763f433cd901c849b5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the total number of available uart devices.  <a href="#a0c361423caa8763f433cd901c849b5a1">More...</a><br /></td></tr>
<tr class="separator:a0c361423caa8763f433cd901c849b5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a0268b4e7376e25abd321394f839f8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#ad4a0268b4e7376e25abd321394f839f8">epcf_uart_getRxBufferCount</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice)</td></tr>
<tr class="memdesc:ad4a0268b4e7376e25abd321394f839f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get number of bytes received in uart receive buffer.  <a href="#ad4a0268b4e7376e25abd321394f839f8">More...</a><br /></td></tr>
<tr class="separator:ad4a0268b4e7376e25abd321394f839f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e6b2c3091eadc80a3340f7c2386c9f"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#a62e6b2c3091eadc80a3340f7c2386c9f">epcf_uart_rxBufferFlush</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice)</td></tr>
<tr class="memdesc:a62e6b2c3091eadc80a3340f7c2386c9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to flush uart receive buffer.  <a href="#a62e6b2c3091eadc80a3340f7c2386c9f">More...</a><br /></td></tr>
<tr class="separator:a62e6b2c3091eadc80a3340f7c2386c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa7a2490d3e0041f24a15d60c450371"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#a5aa7a2490d3e0041f24a15d60c450371">epcf_uart_getTxBufferCount</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice)</td></tr>
<tr class="memdesc:a5aa7a2490d3e0041f24a15d60c450371"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get number of bytes pending in uart transmit buffer.  <a href="#a5aa7a2490d3e0041f24a15d60c450371">More...</a><br /></td></tr>
<tr class="separator:a5aa7a2490d3e0041f24a15d60c450371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c61e55ba45e0f819499596519ea8b49"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="uart_8c.html#a8c61e55ba45e0f819499596519ea8b49">epcf_uart_txBufferFlush</a> (<a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *pUartDevice)</td></tr>
<tr class="memdesc:a8c61e55ba45e0f819499596519ea8b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to flush uart transmit buffer.  <a href="#a8c61e55ba45e0f819499596519ea8b49">More...</a><br /></td></tr>
<tr class="separator:a8c61e55ba45e0f819499596519ea8b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45a02191e355de7199bdc621e289ba1"><td class="memItemLeft" align="right" valign="top"><a id="af45a02191e355de7199bdc621e289ba1"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>epcf_uart_extGetDeviceCount</b> (<a class="el" href="structEPCFUartController.html">EPCFUartController_t</a> *pUartController)</td></tr>
<tr class="separator:af45a02191e355de7199bdc621e289ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">This file is used to configure a UART device. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a43f5e90dda2ee0090d3f4556ee78f739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f5e90dda2ee0090d3f4556ee78f739">&#9670;&nbsp;</a></span>epcf_uart_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_uart_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to close the uart device. It will free the memory allocated by the uart device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to the uart device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="aaacfd07a33e8060b8acf2a8a4e17924d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaacfd07a33e8060b8acf2a8a4e17924d">&#9670;&nbsp;</a></span>epcf_uart_createNative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a>* epcf_uart_createNative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEPCFUartCfg.html">EPCFUartCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pUartConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to create an uart device. Call this function in beginning to initialize the device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling uart functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartConfig</td><td>Pointer to the uart configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, it return the pointer to uart device. On error, it returns NULL. </dd></dl>

</div>
</div>
<a id="a0c361423caa8763f433cd901c849b5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c361423caa8763f433cd901c849b5a1">&#9670;&nbsp;</a></span>epcf_uart_getDeviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t epcf_uart_getDeviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the total number of available uart devices. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of available uart devices. </dd></dl>

</div>
</div>
<a id="ad4a0268b4e7376e25abd321394f839f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a0268b4e7376e25abd321394f839f8">&#9670;&nbsp;</a></span>epcf_uart_getRxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_uart_getRxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get number of bytes received in uart receive buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to uart device structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of received bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when uart is configured in interrupt mode. </dd></dl>

</div>
</div>
<a id="a5aa7a2490d3e0041f24a15d60c450371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa7a2490d3e0041f24a15d60c450371">&#9670;&nbsp;</a></span>epcf_uart_getTxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_uart_getTxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get number of bytes pending in uart transmit buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to uart device structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of pending bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when uart is configured in interrupt mode. </dd></dl>

</div>
</div>
<a id="aa4b4fe3d04fe4bdfbfa0cfd48f36cdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4b4fe3d04fe4bdfbfa0cfd48f36cdb0">&#9670;&nbsp;</a></span>epcf_uart_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_uart_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read data on uart channel. In Interrupt mode, data receiving is asyncronous and data is received in an internal software buffer. Use epcf_uart_getRxBufferCount function to get receive buffer count. When the count is equal to the required number of bytes to be read, call EPCF_UART_READ function to read the buffer. </p>
<p class="">In Polling mode, data receiving will be synchronous and calling function will be blocked until all the data is received or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to uart device structure. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be stored after read operation. </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to send </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes read over uart channel. Check status code in case return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="a62e6b2c3091eadc80a3340f7c2386c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e6b2c3091eadc80a3340f7c2386c9f">&#9670;&nbsp;</a></span>epcf_uart_rxBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_uart_rxBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to flush uart receive buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to uart device structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when uart is configured in interrupt mode. </dd></dl>

</div>
</div>
<a id="a8c61e55ba45e0f819499596519ea8b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c61e55ba45e0f819499596519ea8b49">&#9670;&nbsp;</a></span>epcf_uart_txBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_uart_txBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to flush uart transmit buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to uart device structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when uart is configured in interrupt mode. </dd></dl>

</div>
</div>
<a id="a995f3c9ed32f18ef7aa69b8966983116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995f3c9ed32f18ef7aa69b8966983116">&#9670;&nbsp;</a></span>epcf_uart_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_uart_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send data over uart channel. Use this function in interrupt mode. Data transmission will be asynchronous and the data is transmmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use epcf_uart_getTxBufferCount function to check the status of the transmit buffer. </p>
<p class="">In Polling mode, data transmission will be synchronous and calling function will be blocked until all the data is transmitted or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to uart device structure. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be written is stored. </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to send </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes sent over uart channel. Check status code in case return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="ab122d792b78dbf161bb312b572376a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab122d792b78dbf161bb312b572376a62">&#9670;&nbsp;</a></span>epcf_uart_writeString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_uart_writeString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="uart_8h.html#ac9ec9e319ac81863d7c03f9b5f65b423">EPCFUartDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pUartDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to write string data on uart channel. In Interrupt mode, data transmission will be asynchronous and the data is transmmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use epcf_uart_getTxBufferCount function to check the status of the transmit buffer. </p>
<p class="">In Polling mode, data transmission will be synchronous and calling function will be blocked until all the data is transmitted or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUartDevice</td><td>Pointer to uart device structure. </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where string to be written is stored. </td></tr>
    <tr><td class="paramname">timeout</td><td>Timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes sent over uart channel. Check status code in case return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

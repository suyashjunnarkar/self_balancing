<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: epcf_project/epcf/peripheral/source/i2c/i2c.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a3dd39be04874e8d0c4408dc2fbbe4d9.html">epcf_project</a></li><li class="navelem"><a class="el" href="dir_2f7e3134a884d190e855e94bbd69e569.html">epcf</a></li><li class="navelem"><a class="el" href="dir_2950bcd52e09015d6c88380a30574849.html">peripheral</a></li><li class="navelem"><a class="el" href="dir_a432507043b74a36ac7bfda595ba2ea5.html">source</a></li><li class="navelem"><a class="el" href="dir_a7e545e0fcb03e7f52c7582fd51c447e.html">i2c</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">i2c.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file is used to configure a I2C device.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;pcf.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ada8f2ee61d9c3993af8d3d8ef6e48683"><td class="memItemLeft" align="right" valign="top"><a id="ada8f2ee61d9c3993af8d3d8ef6e48683"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__EPCF_PRIVATE_I2C_H_INCLUDE</b>&#160;&#160;&#160;PCF_CONDITIONAL_INCLUDE_FILE(EPCF_DIR_PATH/,peripheral/source/,i2c/,i2c_hidden.h)</td></tr>
<tr class="separator:ada8f2ee61d9c3993af8d3d8ef6e48683"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3f687b5c66cbdbe03666613dcd9aef94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a3f687b5c66cbdbe03666613dcd9aef94">epcf_i2c_CreateNative</a> (<a class="el" href="structEPCFI2cCfg__t.html">EPCFI2cCfg_t</a> *pI2cConfig)</td></tr>
<tr class="memdesc:a3f687b5c66cbdbe03666613dcd9aef94"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to create a i2c device. Call this function in beginning to initialize the i2c device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling i2c functions.  <a href="#a3f687b5c66cbdbe03666613dcd9aef94">More...</a><br /></td></tr>
<tr class="separator:a3f687b5c66cbdbe03666613dcd9aef94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24f35ecf200ff9e2dec3c2169f634b26"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a24f35ecf200ff9e2dec3c2169f634b26">epcf_i2c_write</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice, EnEPCFBoolean_t masterEnable, uint8_t slaveAddress, const uint8_t *data, uint32_t size, EnEPCFBoolean_t busRelease, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a24f35ecf200ff9e2dec3c2169f634b26"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send data on I2c bus. It can be used in both master and slave mode. In Interrupt mode, data transmission will be asynchronous and the data is transmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use EPCF_I2c_GET_TX_BUFFER_COUNT function to check the status of the transmit buffer.  <a href="#a24f35ecf200ff9e2dec3c2169f634b26">More...</a><br /></td></tr>
<tr class="separator:a24f35ecf200ff9e2dec3c2169f634b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad706f83fd8413715ac0bc5378b0015e5"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ad706f83fd8413715ac0bc5378b0015e5">epcf_i2c_read</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice, EnEPCFBoolean_t masterEnable, uint8_t slaveAddress, uint8_t *data, uint32_t size, EnEPCFBoolean_t busRelease, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:ad706f83fd8413715ac0bc5378b0015e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read data on I2c bus. This function can be used in both master and slave mode. In Interrupt mode, data receiving is asynchronous and data is received in an internal software buffer. Use EPCF_I2c_GET_RX_BUFFER_COUNT function to get receive buffer count. When the count is equal to the required number of bytes to be read, call EPCF_I2c_READ function to read the buffer.  <a href="#ad706f83fd8413715ac0bc5378b0015e5">More...</a><br /></td></tr>
<tr class="separator:ad706f83fd8413715ac0bc5378b0015e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0afd43ef7268ae9360c8ea70a54541"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#acf0afd43ef7268ae9360c8ea70a54541">epcf_i2c_intEnable</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice)</td></tr>
<tr class="memdesc:acf0afd43ef7268ae9360c8ea70a54541"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to enable the I2c interrupt.It can be disabled by <a class="el" href="i2c_8h.html#a54aa1fdbfae89bd17958069e8d58e635" title="This function is used to disable the I2c interrupt. The device can be enabled again by epcf_i2c_intEn...">epcf_i2c_intDisable()</a> function.  <a href="#acf0afd43ef7268ae9360c8ea70a54541">More...</a><br /></td></tr>
<tr class="separator:acf0afd43ef7268ae9360c8ea70a54541"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54aa1fdbfae89bd17958069e8d58e635"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a54aa1fdbfae89bd17958069e8d58e635">epcf_i2c_intDisable</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice)</td></tr>
<tr class="memdesc:a54aa1fdbfae89bd17958069e8d58e635"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to disable the I2c interrupt. The device can be enabled again by <a class="el" href="i2c_8h.html#acf0afd43ef7268ae9360c8ea70a54541" title="This function is used to enable the I2c interrupt.It can be disabled by epcf_i2c_intDisable() functio...">epcf_i2c_intEnable()</a> function.  <a href="#a54aa1fdbfae89bd17958069e8d58e635">More...</a><br /></td></tr>
<tr class="separator:a54aa1fdbfae89bd17958069e8d58e635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc241257a5efd5cd65f5da5ebeb59a65"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#acc241257a5efd5cd65f5da5ebeb59a65">epcf_i2c_getRxBufferCount</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice)</td></tr>
<tr class="separator:acc241257a5efd5cd65f5da5ebeb59a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d512b68b103443365474a689da05ee"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a90d512b68b103443365474a689da05ee">epcf_i2c_rxBufferFlush</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice)</td></tr>
<tr class="separator:a90d512b68b103443365474a689da05ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f89f9f23839f49a11c83ed229bb805"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a53f89f9f23839f49a11c83ed229bb805">epcf_i2c_getTxBufferCount</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice)</td></tr>
<tr class="separator:a53f89f9f23839f49a11c83ed229bb805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ede5bd8a347d4a1a9230bc2e796c6f7"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#a7ede5bd8a347d4a1a9230bc2e796c6f7">epcf_i2c_txBufferFlush</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice)</td></tr>
<tr class="separator:a7ede5bd8a347d4a1a9230bc2e796c6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad40cdebd822ac63221f357d5ef25fd"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#abad40cdebd822ac63221f357d5ef25fd">epcf_i2c_close</a> (<a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *pI2cDevice)</td></tr>
<tr class="memdesc:abad40cdebd822ac63221f357d5ef25fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to close the I2c device. It will free the memory allocated by the I2c device.  <a href="#abad40cdebd822ac63221f357d5ef25fd">More...</a><br /></td></tr>
<tr class="separator:abad40cdebd822ac63221f357d5ef25fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab567c3d619e8d5576d316194be5fb803"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="i2c_8c.html#ab567c3d619e8d5576d316194be5fb803">epcf_i2c_getDeviceCount</a> ()</td></tr>
<tr class="memdesc:ab567c3d619e8d5576d316194be5fb803"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the total number of available I2c devices.  <a href="#ab567c3d619e8d5576d316194be5fb803">More...</a><br /></td></tr>
<tr class="separator:ab567c3d619e8d5576d316194be5fb803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53c4feb398f4a5db059f22e16477c96"><td class="memItemLeft" align="right" valign="top"><a id="ab53c4feb398f4a5db059f22e16477c96"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>epcf_i2c_extGetDeviceCount</b> (EPCFI2cController_t *pI2cController)</td></tr>
<tr class="separator:ab53c4feb398f4a5db059f22e16477c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">This file is used to configure a I2C device. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="abad40cdebd822ac63221f357d5ef25fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad40cdebd822ac63221f357d5ef25fd">&#9670;&nbsp;</a></span>epcf_i2c_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_i2c_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to close the I2c device. It will free the memory allocated by the I2c device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="a3f687b5c66cbdbe03666613dcd9aef94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f687b5c66cbdbe03666613dcd9aef94">&#9670;&nbsp;</a></span>epcf_i2c_CreateNative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a>* epcf_i2c_CreateNative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEPCFI2cCfg__t.html">EPCFI2cCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to create a i2c device. Call this function in beginning to initialize the i2c device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling i2c functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cConfig</td><td>Pointer to the i2c configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, it return the pointer to i2c device. On error, it returns NULL. </dd></dl>

</div>
</div>
<a id="ab567c3d619e8d5576d316194be5fb803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab567c3d619e8d5576d316194be5fb803">&#9670;&nbsp;</a></span>epcf_i2c_getDeviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t epcf_i2c_getDeviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the total number of available I2c devices. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of available I2c devices. </dd></dl>

</div>
</div>
<a id="acc241257a5efd5cd65f5da5ebeb59a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc241257a5efd5cd65f5da5ebeb59a65">&#9670;&nbsp;</a></span>epcf_i2c_getRxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_i2c_getRxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to get number of bytes received in I2c receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of received bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when I2c is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a53f89f9f23839f49a11c83ed229bb805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f89f9f23839f49a11c83ed229bb805">&#9670;&nbsp;</a></span>epcf_i2c_getTxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_i2c_getTxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to get number of bytes pending in I2c transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of pending bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when I2c is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a54aa1fdbfae89bd17958069e8d58e635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54aa1fdbfae89bd17958069e8d58e635">&#9670;&nbsp;</a></span>epcf_i2c_intDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_i2c_intDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to disable the I2c interrupt. The device can be enabled again by <a class="el" href="i2c_8h.html#acf0afd43ef7268ae9360c8ea70a54541" title="This function is used to enable the I2c interrupt.It can be disabled by epcf_i2c_intDisable() functio...">epcf_i2c_intEnable()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device. </td></tr>
    <tr><td class="paramname">intType</td><td>interrupt type to generate an interrupt.Refer Enum EnEPCFIntType_t. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="acf0afd43ef7268ae9360c8ea70a54541"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf0afd43ef7268ae9360c8ea70a54541">&#9670;&nbsp;</a></span>epcf_i2c_intEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_i2c_intEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to enable the I2c interrupt.It can be disabled by <a class="el" href="i2c_8h.html#a54aa1fdbfae89bd17958069e8d58e635" title="This function is used to disable the I2c interrupt. The device can be enabled again by epcf_i2c_intEn...">epcf_i2c_intDisable()</a> function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device. </td></tr>
    <tr><td class="paramname">intType</td><td>interrupt type to generate an interrupt.Refer Enum EnEPCFIntType_t.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="ad706f83fd8413715ac0bc5378b0015e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad706f83fd8413715ac0bc5378b0015e5">&#9670;&nbsp;</a></span>epcf_i2c_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_i2c_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnEPCFBoolean_t&#160;</td>
          <td class="paramname"><em>masterEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnEPCFBoolean_t&#160;</td>
          <td class="paramname"><em>busRelease</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read data on I2c bus. This function can be used in both master and slave mode. In Interrupt mode, data receiving is asynchronous and data is received in an internal software buffer. Use EPCF_I2c_GET_RX_BUFFER_COUNT function to get receive buffer count. When the count is equal to the required number of bytes to be read, call EPCF_I2c_READ function to read the buffer. </p>
<p class="">In Polling mode, data receiving will be synchronous and calling function will be blocked until all the data is received or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device </td></tr>
    <tr><td class="paramname">masterEnable</td><td>Make it true if want to use this function in master mode. </td></tr>
    <tr><td class="paramname">slaveAddress</td><td>Address of the slave device </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data read is to be stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to be read </td></tr>
    <tr><td class="paramname">busRelease</td><td>Make it true if want to release the bus after receiving all data. </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return number of bytes read over I2c bus. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="a90d512b68b103443365474a689da05ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d512b68b103443365474a689da05ee">&#9670;&nbsp;</a></span>epcf_i2c_rxBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_i2c_rxBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to flush I2c receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when I2c is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a7ede5bd8a347d4a1a9230bc2e796c6f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ede5bd8a347d4a1a9230bc2e796c6f7">&#9670;&nbsp;</a></span>epcf_i2c_txBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_i2c_txBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to flush I2c transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when I2c is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a24f35ecf200ff9e2dec3c2169f634b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24f35ecf200ff9e2dec3c2169f634b26">&#9670;&nbsp;</a></span>epcf_i2c_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_i2c_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="i2c_8h.html#abad1f65160a59e1e3ceefa2645e755c6">EPCFI2cDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pI2cDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnEPCFBoolean_t&#160;</td>
          <td class="paramname"><em>masterEnable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EnEPCFBoolean_t&#160;</td>
          <td class="paramname"><em>busRelease</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send data on I2c bus. It can be used in both master and slave mode. In Interrupt mode, data transmission will be asynchronous and the data is transmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use EPCF_I2c_GET_TX_BUFFER_COUNT function to check the status of the transmit buffer. </p>
<p class="">In Polling mode, data transmission will be synchronous and calling function will be blocked until all the data is transmitted or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pI2cDevice</td><td>Pointer to the I2c device </td></tr>
    <tr><td class="paramname">masterEnable</td><td>Make it true if want to use this function in master mode. </td></tr>
    <tr><td class="paramname">slaveAddress</td><td>Address of the slave device </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be write is stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to be read </td></tr>
    <tr><td class="paramname">busRelease</td><td>Make it true if want to release the bus after receiving all data. </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes send over I2c bus. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: epcf_project/epcf/peripheral/source/spi/spi.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_a3dd39be04874e8d0c4408dc2fbbe4d9.html">epcf_project</a></li><li class="navelem"><a class="el" href="dir_2f7e3134a884d190e855e94bbd69e569.html">epcf</a></li><li class="navelem"><a class="el" href="dir_2950bcd52e09015d6c88380a30574849.html">peripheral</a></li><li class="navelem"><a class="el" href="dir_a432507043b74a36ac7bfda595ba2ea5.html">source</a></li><li class="navelem"><a class="el" href="dir_8ec6567c7eaee3e1ec1e14c7c0e3fdde.html">spi</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">spi.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file is used to configure a SPI device.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;pcf.h&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a219ea3d7a2dd913c70d1917bc5517290"><td class="memItemLeft" align="right" valign="top"><a id="a219ea3d7a2dd913c70d1917bc5517290"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>__EPCF_SPI_HIDDEN_INCLUDE</b>&#160;&#160;&#160;PCF_CONDITIONAL_INCLUDE_FILE(EPCF_DIR_PATH/,peripheral/source/,spi/,spi_hidden.h)</td></tr>
<tr class="separator:a219ea3d7a2dd913c70d1917bc5517290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf886c807944d1fc5b254c835774ca7"><td class="memItemLeft" align="right" valign="top"><a id="aabf886c807944d1fc5b254c835774ca7"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>_SPI_DEBUG</b>&#160;&#160;&#160;PCF_ENABLE</td></tr>
<tr class="separator:aabf886c807944d1fc5b254c835774ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a418ebdaad333a7cfa90d00d429faf1ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a418ebdaad333a7cfa90d00d429faf1ae">epcf_spi_createNative</a> (<a class="el" href="structEPCFSpiCfg__t.html">EPCFSpiCfg_t</a> *pSpiConfig)</td></tr>
<tr class="memdesc:a418ebdaad333a7cfa90d00d429faf1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to create an spi device. Call this function in beginning to initialize the device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling spi functions.  <a href="#a418ebdaad333a7cfa90d00d429faf1ae">More...</a><br /></td></tr>
<tr class="separator:a418ebdaad333a7cfa90d00d429faf1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eaa379aa69133277ef3b0b557e0d1b0"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a6eaa379aa69133277ef3b0b557e0d1b0">epcf_spi_close</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice)</td></tr>
<tr class="memdesc:a6eaa379aa69133277ef3b0b557e0d1b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to close the spi device. It will free the memory allocated by the spi device.  <a href="#a6eaa379aa69133277ef3b0b557e0d1b0">More...</a><br /></td></tr>
<tr class="separator:a6eaa379aa69133277ef3b0b557e0d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28b8780e75f9a0fd238291447e8a4cf"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#ad28b8780e75f9a0fd238291447e8a4cf">epcf_spi_registerSlaveDevice</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, EPCFPortPin_t slaveSelectPin)</td></tr>
<tr class="memdesc:ad28b8780e75f9a0fd238291447e8a4cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to register a spi slave device. Call this function once in the begining to register slaveSelectPin of the slave device should be registered before doing any read write operation for that device. The function will return a slaveId which can be used to select and unselect the slave device using epcf_spi_slaveSelect and epcf_spi_slaveDeSelect function respectively.  <a href="#ad28b8780e75f9a0fd238291447e8a4cf">More...</a><br /></td></tr>
<tr class="separator:ad28b8780e75f9a0fd238291447e8a4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbe02b68bad7a5aba34264c5731c234"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a9fbe02b68bad7a5aba34264c5731c234">epcf_spi_deRegisterSlaveDevice</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, uint8_t slaveId)</td></tr>
<tr class="memdesc:a9fbe02b68bad7a5aba34264c5731c234"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to unregister a spi slave device. No operation on the slave device is possible once it is unregistered. Register the slave device again to operate on the device once it is unregistered.  <a href="#a9fbe02b68bad7a5aba34264c5731c234">More...</a><br /></td></tr>
<tr class="separator:a9fbe02b68bad7a5aba34264c5731c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b274135b17faf771815b1e5f2909b31"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a8b274135b17faf771815b1e5f2909b31">epcf_spi_slaveSelect</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, uint8_t slaveId)</td></tr>
<tr class="memdesc:a8b274135b17faf771815b1e5f2909b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to select the slave device on the spi bus before starting any communication with the device.  <a href="#a8b274135b17faf771815b1e5f2909b31">More...</a><br /></td></tr>
<tr class="separator:a8b274135b17faf771815b1e5f2909b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cf5feaf6b13908851c3264df5c9405"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a90cf5feaf6b13908851c3264df5c9405">epcf_spi_slaveDeSelect</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, uint8_t slaveId)</td></tr>
<tr class="memdesc:a90cf5feaf6b13908851c3264df5c9405"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to unselect the slave device after communication with the device is finished.  <a href="#a90cf5feaf6b13908851c3264df5c9405">More...</a><br /></td></tr>
<tr class="separator:a90cf5feaf6b13908851c3264df5c9405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792532296a93636fde4b30e1cda82aca"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a792532296a93636fde4b30e1cda82aca">epcf_spi_exchange</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, uint16_t txData, uint16_t *rxData, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a792532296a93636fde4b30e1cda82aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to exchange a single frame over spi bus. It can be used in both master and slave mode. The size of the frame is according to setting of the dataBits field in spi configuration. The calling function will be blocked until the data frame is exchanged or timeout has occurred. The function is a blocking call in both interrupt and polling mode.  <a href="#a792532296a93636fde4b30e1cda82aca">More...</a><br /></td></tr>
<tr class="separator:a792532296a93636fde4b30e1cda82aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067baf1e065e651159c87670fca2336d"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a067baf1e065e651159c87670fca2336d">epcf_spi_write</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, const uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:a067baf1e065e651159c87670fca2336d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to send data on spi bus. It can be used in both master and slave mode. In Interrupt mode, data transmission will be asynchronous and the data is transmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use epcf_spi_getTxBufferCount function to check the status of the transmit buffer.  <a href="#a067baf1e065e651159c87670fca2336d">More...</a><br /></td></tr>
<tr class="separator:a067baf1e065e651159c87670fca2336d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add28918493fe97abb634840047a9d65a"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#add28918493fe97abb634840047a9d65a">epcf_spi_read</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, uint8_t *data, uint32_t size, EPCFTime_t timeout)</td></tr>
<tr class="memdesc:add28918493fe97abb634840047a9d65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to read data on spi bus. This function can be used in both master and slave mode. In Interrupt mode, data receiving is asynchronous and data is received in an internal software buffer. Use epcf_spi_getRxBufferCount function to get receive buffer count. When the count is equal to the required number of bytes to be read, call epcf_spi_read function to read the buffer.  <a href="#add28918493fe97abb634840047a9d65a">More...</a><br /></td></tr>
<tr class="separator:add28918493fe97abb634840047a9d65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d33135fde22d6a199596af503cfd7e"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a74d33135fde22d6a199596af503cfd7e">epcf_spi_intEnable</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, <a class="el" href="spi_8h.html#a270c561e7d4dc10fee5b99a87b3d4e5d">EnEPCFSpiIntType</a> intType)</td></tr>
<tr class="memdesc:a74d33135fde22d6a199596af503cfd7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to enable the spi interrupt.It can be disabled by a call to the function epcfNativeSpiIntDisable.  <a href="#a74d33135fde22d6a199596af503cfd7e">More...</a><br /></td></tr>
<tr class="separator:a74d33135fde22d6a199596af503cfd7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc395b3cca7808342d741b2eb9ee7929"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#afc395b3cca7808342d741b2eb9ee7929">epcf_spi_intDisable</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice, <a class="el" href="spi_8h.html#a270c561e7d4dc10fee5b99a87b3d4e5d">EnEPCFSpiIntType</a> intType)</td></tr>
<tr class="memdesc:afc395b3cca7808342d741b2eb9ee7929"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to disable the spi interrupt.It can be enable by a call to the function epcfNativeSpiIntEnable.  <a href="#afc395b3cca7808342d741b2eb9ee7929">More...</a><br /></td></tr>
<tr class="separator:afc395b3cca7808342d741b2eb9ee7929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d294f72c2127f0cf71d1e0f5772f137"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a4d294f72c2127f0cf71d1e0f5772f137">epcf_spi_getRxBufferCount</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice)</td></tr>
<tr class="separator:a4d294f72c2127f0cf71d1e0f5772f137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5307b8726ae2facf01cf5bc0ff15b2"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a9d5307b8726ae2facf01cf5bc0ff15b2">epcf_spi_rxBufferFlush</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice)</td></tr>
<tr class="separator:a9d5307b8726ae2facf01cf5bc0ff15b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca145d8c830302ac631c8988c5213cf4"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#aca145d8c830302ac631c8988c5213cf4">epcf_spi_getTxBufferCount</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice)</td></tr>
<tr class="separator:aca145d8c830302ac631c8988c5213cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c2f27d5829139f7f02b52c7b414671"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a02c2f27d5829139f7f02b52c7b414671">epcf_spi_txBufferFlush</a> (<a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *pSpiDevice)</td></tr>
<tr class="separator:a02c2f27d5829139f7f02b52c7b414671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050d7585f7957c76bb1f98a639a7b31d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="spi_8c.html#a050d7585f7957c76bb1f98a639a7b31d">epcf_spi_getDeviceCount</a> ()</td></tr>
<tr class="memdesc:a050d7585f7957c76bb1f98a639a7b31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is used to get the total number of available spi devices.  <a href="#a050d7585f7957c76bb1f98a639a7b31d">More...</a><br /></td></tr>
<tr class="separator:a050d7585f7957c76bb1f98a639a7b31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p class="">This file is used to configure a SPI device. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a6eaa379aa69133277ef3b0b557e0d1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eaa379aa69133277ef3b0b557e0d1b0">&#9670;&nbsp;</a></span>epcf_spi_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to close the spi device. It will free the memory allocated by the spi device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="a418ebdaad333a7cfa90d00d429faf1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418ebdaad333a7cfa90d00d429faf1ae">&#9670;&nbsp;</a></span>epcf_spi_createNative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a>* epcf_spi_createNative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structEPCFSpiCfg__t.html">EPCFSpiCfg_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to create an spi device. Call this function in beginning to initialize the device. This function allocates memory for the device using malloc() function call and returns a pointer to the device. Pass this device pointer while calling spi functions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiConfig</td><td>Pointer to the spi configuration structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, it return the pointer to spi device. On error, it returns NULL. </dd></dl>

</div>
</div>
<a id="a9fbe02b68bad7a5aba34264c5731c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbe02b68bad7a5aba34264c5731c234">&#9670;&nbsp;</a></span>epcf_spi_deRegisterSlaveDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_deRegisterSlaveDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to unregister a spi slave device. No operation on the slave device is possible once it is unregistered. Register the slave device again to operate on the device once it is unregistered. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device </td></tr>
    <tr><td class="paramname">slaveId</td><td>slaveId returned by epcf_spi_registerSlaveDevice function</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when using spi in master mode. </dd></dl>

</div>
</div>
<a id="a792532296a93636fde4b30e1cda82aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792532296a93636fde4b30e1cda82aca">&#9670;&nbsp;</a></span>epcf_spi_exchange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_exchange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>txData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>rxData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to exchange a single frame over spi bus. It can be used in both master and slave mode. The size of the frame is according to setting of the dataBits field in spi configuration. The calling function will be blocked until the data frame is exchanged or timeout has occurred. The function is a blocking call in both interrupt and polling mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device </td></tr>
    <tr><td class="paramname">txData</td><td>data frame to be transmitted </td></tr>
    <tr><td class="paramname">rxData</td><td>Pointer to the data frame where received data will be stored </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns 1 when frame is successfully exchanged. Check status code in case return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Master mode(master write):<ol type="1">
<li>Call epcf_spi_slaveSelect function to select the slave device.</li>
<li>Call epcf_spi_exchange function to exchange a single frame from the slave device.</li>
<li>Call epcf_spi_slaveDeSelect function to unselect the slave device.</li>
</ol>
</dd></dl>
<p>Slave mode(Slave write): Call this function to write data to the master device. </p>

</div>
</div>
<a id="a050d7585f7957c76bb1f98a639a7b31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050d7585f7957c76bb1f98a639a7b31d">&#9670;&nbsp;</a></span>epcf_spi_getDeviceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t epcf_spi_getDeviceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to get the total number of available spi devices. </p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of available spi devices. </dd></dl>

</div>
</div>
<a id="a4d294f72c2127f0cf71d1e0f5772f137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d294f72c2127f0cf71d1e0f5772f137">&#9670;&nbsp;</a></span>epcf_spi_getRxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_spi_getRxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to get number of bytes received in spi receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of received bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when spi is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="aca145d8c830302ac631c8988c5213cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca145d8c830302ac631c8988c5213cf4">&#9670;&nbsp;</a></span>epcf_spi_getTxBufferCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t epcf_spi_getTxBufferCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to get number of bytes pending in spi transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of pending bytes</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when spi is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="afc395b3cca7808342d741b2eb9ee7929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc395b3cca7808342d741b2eb9ee7929">&#9670;&nbsp;</a></span>epcf_spi_intDisable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_intDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a270c561e7d4dc10fee5b99a87b3d4e5d">EnEPCFSpiIntType</a>&#160;</td>
          <td class="paramname"><em>intType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to disable the spi interrupt.It can be enable by a call to the function epcfNativeSpiIntEnable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device. </td></tr>
    <tr><td class="paramname">intType</td><td>type of interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="a74d33135fde22d6a199596af503cfd7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74d33135fde22d6a199596af503cfd7e">&#9670;&nbsp;</a></span>epcf_spi_intEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_intEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a270c561e7d4dc10fee5b99a87b3d4e5d">EnEPCFSpiIntType</a>&#160;</td>
          <td class="paramname"><em>intType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to enable the spi interrupt.It can be disabled by a call to the function epcfNativeSpiIntDisable. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device. </td></tr>
    <tr><td class="paramname">intType</td><td>type of interrupt</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes. </dd></dl>

</div>
</div>
<a id="add28918493fe97abb634840047a9d65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add28918493fe97abb634840047a9d65a">&#9670;&nbsp;</a></span>epcf_spi_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to read data on spi bus. This function can be used in both master and slave mode. In Interrupt mode, data receiving is asynchronous and data is received in an internal software buffer. Use epcf_spi_getRxBufferCount function to get receive buffer count. When the count is equal to the required number of bytes to be read, call epcf_spi_read function to read the buffer. </p>
<p class="">In Polling mode, data receiving will be synchronous and calling function will be blocked until all the data is received or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be read is stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to be read </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return number of bytes read over spi bus. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If value of dataBits is set to greater than 8 bits. Then, 2 consecutive bytes will represent 1 single frame. In this case value of size should be in a multiple of 2. If the value of size is an odd value, then a 0 is padded as the last byte of the data.</dd></dl>
<p>Master mode(master read):</p><ol type="1">
<li>Call epcf_spi_slaveSelect function to select the slave device.</li>
<li>Call epcf_spi_read function to read data from the slave.</li>
<li>Call epcf_spi_slaveDeSelect function to de-select the slave device after data reception is completed.</li>
</ol>
<p class="">Slave mode(slave read): Call this function to read data received from the master device. </p>

</div>
</div>
<a id="ad28b8780e75f9a0fd238291447e8a4cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28b8780e75f9a0fd238291447e8a4cf">&#9670;&nbsp;</a></span>epcf_spi_registerSlaveDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_registerSlaveDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFPortPin_t&#160;</td>
          <td class="paramname"><em>slaveSelectPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to register a spi slave device. Call this function once in the begining to register slaveSelectPin of the slave device should be registered before doing any read write operation for that device. The function will return a slaveId which can be used to select and unselect the slave device using epcf_spi_slaveSelect and epcf_spi_slaveDeSelect function respectively. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device </td></tr>
    <tr><td class="paramname">slaveSelectPin</td><td>slaveSelectPin information of the slave device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return slaveId. Check status code in case return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when using spi in master mode. </dd></dl>

</div>
</div>
<a id="a9d5307b8726ae2facf01cf5bc0ff15b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5307b8726ae2facf01cf5bc0ff15b2">&#9670;&nbsp;</a></span>epcf_spi_rxBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_rxBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to flush spi receive buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when spi is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a90cf5feaf6b13908851c3264df5c9405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cf5feaf6b13908851c3264df5c9405">&#9670;&nbsp;</a></span>epcf_spi_slaveDeSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_slaveDeSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to unselect the slave device after communication with the device is finished. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device </td></tr>
    <tr><td class="paramname">slaveId</td><td>slaveId of the slave device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when using spi in master mode. </dd></dl>

</div>
</div>
<a id="a8b274135b17faf771815b1e5f2909b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b274135b17faf771815b1e5f2909b31">&#9670;&nbsp;</a></span>epcf_spi_slaveSelect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_slaveSelect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to select the slave device on the spi bus before starting any communication with the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device </td></tr>
    <tr><td class="paramname">slaveId</td><td>slaveId of the slave device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when using spi in master mode. </dd></dl>

</div>
</div>
<a id="a02c2f27d5829139f7f02b52c7b414671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c2f27d5829139f7f02b52c7b414671">&#9670;&nbsp;</a></span>epcf_spi_txBufferFlush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_txBufferFlush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p class="">This function is used to flush spi transmit buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return status. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Use this function only when spi is configured in interrupt mode </dd></dl>

</div>
</div>
<a id="a067baf1e065e651159c87670fca2336d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067baf1e065e651159c87670fca2336d">&#9670;&nbsp;</a></span>epcf_spi_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t epcf_spi_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="spi_8h.html#a7bb251eca0c0226bb3fd854366b9e9ef">EPCFSpiDevice_t</a> *&#160;</td>
          <td class="paramname"><em>pSpiDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">EPCFTime_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is used to send data on spi bus. It can be used in both master and slave mode. In Interrupt mode, data transmission will be asynchronous and the data is transmitted using internal software buffer. The function will be non blocking and will return after initiating data transmission. Use epcf_spi_getTxBufferCount function to check the status of the transmit buffer. </p>
<p class="">In Polling mode, data transmission will be synchronous and calling function will be blocked until all the data is transmitted or timeout has occurred.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSpiDevice</td><td>Pointer to the spi device </td></tr>
    <tr><td class="paramname">data</td><td>Pointer to buffer where data to be written is stored </td></tr>
    <tr><td class="paramname">size</td><td>Total number of bytes to send </td></tr>
    <tr><td class="paramname">timeout</td><td>timeout value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return total number of bytes send over spi bus. Check status code if return value is less than 0. Refer to "../../common/status.h" header file for the appropriate status codes.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>If value of dataBits is set to greater than 8 bits. Then, 2 consecutive bytes will represent 1 single frame. In this case value of size should be in a multiple of 2. If the value of size is an odd value, then a 0 is padded as the last byte of the data.</dd></dl>
<p>Master mode(master write):</p><ol type="1">
<li>Call epcf_spi_slaveSelect function to select the slave device.</li>
<li>Call epcf_spi_write function to send data to the slave.</li>
<li>Call epcf_spi_slaveDeSelect function to de-select the slave device after data transmission is completed.</li>
</ol>
<p class="">Slave mode(Slave write): Call this function to write data to the master device. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
